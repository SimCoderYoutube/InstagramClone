{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport * as Utils from \"./WebCameraUtils\";\nimport { FacingModeToCameraType } from \"./WebConstants\";\nvar VALID_SETTINGS_KEYS = ['autoFocus', 'flashMode', 'exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'whiteBalance', 'zoom'];\n\nfunction useLoadedVideo(video, onLoaded) {\n  React.useEffect(function () {\n    if (video) {\n      video.addEventListener('loadedmetadata', function () {\n        requestAnimationFrame(function () {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(video, preferredType, settings, _ref) {\n  var onCameraReady = _ref.onCameraReady,\n      onMountError = _ref.onMountError;\n  var isStartingCamera = React.useRef(false);\n  var activeStreams = React.useRef([]);\n  var capabilities = React.useRef({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1\n  });\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      stream = _React$useState2[0],\n      setStream = _React$useState2[1];\n\n  var mediaTrackSettings = React.useMemo(function () {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n  var type = React.useMemo(function () {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n\n    var _mediaTrackSettings$f = mediaTrackSettings.facingMode,\n        facingMode = _mediaTrackSettings$f === void 0 ? 'user' : _mediaTrackSettings$f;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n  var getStreamDeviceAsync = React.useCallback(function _callee() {\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(Utils.getPreferredStreamDevice(preferredType));\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 6:\n            _context.prev = 6;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (__DEV__) {\n              console.warn(\"Error requesting UserMedia for type \\\"\" + preferredType + \"\\\":\", _context.t0);\n            }\n\n            if (onMountError) {\n              onMountError({\n                nativeEvent: _context.t0\n              });\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 6]], Promise);\n  }, [preferredType, onMountError]);\n  var resumeAsync = React.useCallback(function _callee2() {\n    var nextStream;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(getStreamDeviceAsync());\n\n          case 2:\n            nextStream = _context2.sent;\n\n            if (!Utils.compareStreams(nextStream, stream)) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 5:\n            if (!activeStreams.current.some(function (value) {\n              return value.id === (nextStream == null ? void 0 : nextStream.id);\n            })) {\n              activeStreams.current.push(nextStream);\n            }\n\n            setStream(nextStream);\n\n            if (onCameraReady) {\n              onCameraReady();\n            }\n\n            return _context2.abrupt(\"return\", false);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n  React.useEffect(function () {\n    if (isStartingCamera.current) {\n      return;\n    }\n\n    isStartingCamera.current = true;\n    resumeAsync().then(function (isStarting) {\n      isStartingCamera.current = isStarting;\n    }).catch(function () {\n      isStartingCamera.current = false;\n    });\n  }, [preferredType]);\n  React.useEffect(function () {\n    var changes = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(settings); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n\n      var nextValue = settings[key];\n\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    var hasChanges = !!Object.keys(changes).length;\n\n    var nextWebCameraSettings = _objectSpread(_objectSpread({}, capabilities.current), changes);\n\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [settings.autoFocus, settings.flashMode, settings.exposureCompensation, settings.colorTemperature, settings.iso, settings.brightness, settings.contrast, settings.saturation, settings.sharpness, settings.focusDistance, settings.whiteBalance, settings.zoom]);\n  React.useEffect(function () {\n    if (!video.current) {\n      return;\n    }\n\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n  React.useEffect(function () {\n    return function () {\n      for (var _iterator = _createForOfIteratorHelperLoose(activeStreams.current), _step; !(_step = _iterator()).done;) {\n        var _stream = _step.value;\n        Utils.stopMediaStream(_stream);\n      }\n\n      if (video.current) {\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n  useLoadedVideo(video.current, function () {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n  return {\n    type: type,\n    mediaTrackSettings: mediaTrackSettings\n  };\n}","map":{"version":3,"sources":["../src/useWebCameraStream.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-env browser */\nimport * as React from 'react';\n\nimport {\n  CameraReadyListener,\n  CameraType,\n  MountErrorListener,\n  WebCameraSettings,\n} from './Camera.types';\nimport * as Utils from './WebCameraUtils';\nimport { FacingModeToCameraType } from './WebConstants';\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n];\n\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\n  React.useEffect(() => {\n    if (video) {\n      video.addEventListener('loadedmetadata', () => {\n        // without this async block the constraints aren't properly applied to the camera,\n        // this means that if you were to turn on the torch and swap to the front camera,\n        // then swap back to the rear camera the torch setting wouldn't be applied.\n        requestAnimationFrame(() => {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  preferredType: CameraType,\n  settings: Record<string, any>,\n  {\n    onCameraReady,\n    onMountError,\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\n): {\n  type: CameraType | null;\n  mediaTrackSettings: MediaTrackSettings | null;\n} {\n  const isStartingCamera = React.useRef<boolean | null>(false);\n  const activeStreams = React.useRef<MediaStream[]>([]);\n  const capabilities = React.useRef<WebCameraSettings>({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  });\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\n\n  const mediaTrackSettings = React.useMemo(() => {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n\n  // The actual camera type - this can be different from the incoming camera type.\n  const type = React.useMemo(() => {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n    const { facingMode = 'user' } = mediaTrackSettings;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\n    try {\n      return await Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({ nativeEvent });\n      }\n      return null;\n    }\n  }, [preferredType, onMountError]);\n\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\n    const nextStream = await getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      // Do nothing if the streams are the same.\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\n      // Without this check there is a screen flash while the video switches.\n      return false;\n    }\n\n    // Save a history of all active streams (usually 2+) so we can close them later.\n    // Keeping them open makes swapping camera types much faster.\n    if (!activeStreams.current.some(value => value.id === nextStream?.id)) {\n      activeStreams.current.push(nextStream!);\n    }\n\n    // Set the new stream -> update the video, settings, and actual camera type.\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n\n  React.useEffect(() => {\n    // Restart the camera and guard concurrent actions.\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n\n    resumeAsync()\n      .then(isStarting => {\n        isStartingCamera.current = isStarting;\n      })\n      .catch(() => {\n        // ensure the camera can be started again.\n        isStartingCamera.current = false;\n      });\n  }, [preferredType]);\n\n  // Update the native camera with any custom capabilities.\n  React.useEffect(() => {\n    const changes: WebCameraSettings = {};\n\n    for (const key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n      const nextValue = settings[key];\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [\n    settings.autoFocus,\n    settings.flashMode,\n    settings.exposureCompensation,\n    settings.colorTemperature,\n    settings.iso,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.sharpness,\n    settings.focusDistance,\n    settings.whiteBalance,\n    settings.zoom,\n  ]);\n\n  React.useEffect(() => {\n    // set or unset the video source.\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n\n  React.useEffect(() => {\n    return () => {\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\n      for (const stream of activeStreams.current) {\n        // Close all open streams.\n        Utils.stopMediaStream(stream);\n      }\n      if (video.current) {\n        // Invalidate the video source.\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n\n  // Update props when the video loads.\n  useLoadedVideo(video.current, () => {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n\n  return {\n    type,\n    mediaTrackSettings,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}